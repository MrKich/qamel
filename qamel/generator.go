package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	fp "path/filepath"
	"regexp"
	"runtime"
	"strings"
)

var (
	rxMakefile    = regexp.MustCompile(`^(\S+)\s*=\s*(.+)$`)
	rxCompilerVar = regexp.MustCompile(`\$\((\S+)\)`)
)

// Generator is struct for generating cgo, moc and rcc files
type Generator struct {
	Qmake string
	Moc   string
	Rcc   string
}

// CreateCgoFlags creates cgo flags by using qmake
func (gen Generator) CreateCgoFlags() (string, error) {
	// Get temp dir
	tmpDir := os.TempDir()

	// Create temp project file
	proFilePath := fp.Join(tmpDir, "qamel.pro")
	proFile, err := os.Create(proFilePath)
	if err != nil {
		return "", err
	}
	defer proFile.Close()

	_, err = proFile.WriteString("QT += qml quick")
	if err != nil {
		return "", err
	}
	proFile.Sync()

	// Create makefile from project file using qmake
	makeFilePath := fp.Join(tmpDir, "qamel.makefile")

	qmakeSpec := ""
	switch runtime.GOOS {
	case "darwin":
		qmakeSpec = "macx-clang"
	case "linux":
		qmakeSpec = "linux-g++"
	case "windows":
		qmakeSpec = "win32-g++"
	}

	cmdQmake := exec.Command(gen.Qmake, "-o", makeFilePath, "-spec", qmakeSpec, proFilePath)
	if err = cmdQmake.Run(); err != nil {
		return "", err
	}

	// Parse makefile
	mapCompiler := map[string]string{}

	makeFile, err := os.Open(makeFilePath)
	if err != nil {
		return "", err
	}
	defer makeFile.Close()

	scanner := bufio.NewScanner(makeFile)
	for scanner.Scan() {
		text := scanner.Text()
		parts := rxMakefile.FindStringSubmatch(text)
		if len(parts) != 3 {
			continue
		}

		mapCompiler[parts[1]] = parts[2]
	}

	if err := scanner.Err(); err != nil {
		return "", err
	}

	// Convert variable in compiler flags
	for flagKey, flagValue := range mapCompiler {
		variables := rxCompilerVar.FindAllString(flagValue, -1)
		for _, variable := range variables {
			variableKey := rxCompilerVar.ReplaceAllString(variable, "$1")
			variableValue := mapCompiler[variableKey]
			flagValue = strings.Replace(flagValue, variable, variableValue, -1)
		}

		mapCompiler[flagKey] = strings.TrimSpace(flagValue)
	}

	// Fetch the needed flags for cgo
	cgoFlags := fmt.Sprintf("#cgo CFLAGS: %s\n", mapCompiler["CFLAGS"])
	cgoFlags += fmt.Sprintf("#cgo CXXFLAGS: %s\n", mapCompiler["CXXFLAGS"])
	cgoFlags += fmt.Sprintf("#cgo CXXFLAGS: %s\n", mapCompiler["INCPATH"])
	cgoFlags += fmt.Sprintf("#cgo LDFLAGS: %s\n", mapCompiler["LFLAGS"])
	cgoFlags += fmt.Sprintf("#cgo LDFLAGS: %s\n", mapCompiler["LIBS"])
	cgoFlags += fmt.Sprintln("#cgo CFLAGS: -Wno-unused-parameter -Wno-unused-variable -Wno-return-type")
	cgoFlags += fmt.Sprint("#cgo CXXFLAGS: -Wno-unused-parameter -Wno-unused-variable -Wno-return-type")

	return cgoFlags, nil
}

// CreateCgoFile creates cgo file in specified package, using cgo flags that generated by CreateCgoFlags().
func (gen Generator) CreateCgoFile(dstDir string, cgoFlags string) error {
	// Make sure target directory is exists
	os.MkdirAll(dstDir, os.ModePerm)

	// Get the package name
	pkgName, err := getPackageNameFromDir(qamelDir)
	if err != nil {
		return err
	}

	// Create destination file
	fileName := fp.Join(dstDir, "cgo-"+pkgName+".go")
	dstFile, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	fileContent := fmt.Sprintln("package " + pkgName)
	fileContent += fmt.Sprintln()
	fileContent += fmt.Sprintln("/*")
	fileContent += fmt.Sprintln(cgoFlags)
	fileContent += fmt.Sprintln("*/")
	fileContent += fmt.Sprintln(`import "C"`)

	_, err = dstFile.WriteString(fileContent)
	if err != nil {
		return err
	}

	return dstFile.Sync()
}

// CreateMocFile creates moc file from the specified source.
// If destination is not specified, the moc file will be saved in
// file "moc-" + source.name + ".h"
func (gen Generator) CreateMocFile(src string, dst string) error {
	// Make sure source is exist
	if !fileExists(src) {
		return fmt.Errorf("source file is not exists")
	}

	// Create destination name
	if dst == "" {
		dst = "moc-" + fp.Base(src)
		dst = strings.TrimSuffix(dst, fp.Ext(dst)) + ".h"
		dst = fp.Join(fp.Dir(src), dst)
	}

	// Run moc
	cmdMoc := exec.Command(gen.Moc, "-o", dst, src)
	return cmdMoc.Run()
}

// SaveToFile saves the generator as JSON in ${XDG_CONFIG_HOME}/qamel/config
func (gen Generator) SaveToFile() error {
	// Make sure config dir is exists
	os.MkdirAll(fp.Dir(configPath), os.ModePerm)

	// Create file
	configFile, err := os.Create(configPath)
	if err != nil {
		return err
	}
	defer configFile.Close()

	// Encode generator to JSON
	return json.NewEncoder(configFile).Encode(&gen)
}
