package generator

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	fp "path/filepath"
	"regexp"
	"runtime"
	"strings"
)

var (
	rxMakefile    = regexp.MustCompile(`^(\S+)\s*=\s*(.+)$`)
	rxCompilerVar = regexp.MustCompile(`\$\((\S+)\)`)
)

// CreateCgoFlags creates cgo flags by using qmake
func CreateCgoFlags(qmakePath string) (string, error) {
	// Get temp dir
	tmpDir := os.TempDir()

	// Create temp project file
	proFilePath := fp.Join(tmpDir, "qamel.pro")
	proFile, err := os.Create(proFilePath)
	if err != nil {
		return "", err
	}
	defer proFile.Close()

	_, err = proFile.WriteString("QT += qml quick")
	if err != nil {
		return "", err
	}
	proFile.Sync()

	// Create makefile from project file using qmake
	makeFilePath := fp.Join(tmpDir, "qamel.makefile")

	qmakeSpec := ""
	switch runtime.GOOS {
	case "darwin":
		qmakeSpec = "macx-clang"
	case "linux":
		qmakeSpec = "linux-g++"
	case "windows":
		qmakeSpec = "win32-g++"
	}

	cmdQmake := exec.Command(qmakePath, "-o", makeFilePath, "-spec", qmakeSpec, proFilePath)
	if btOutput, err := cmdQmake.CombinedOutput(); err != nil {
		return "", fmt.Errorf("%v\n%s", err, btOutput)
	}

	// Parse makefile
	if runtime.GOOS == "windows" {
		makeFilePath += ".Release"
	}

	mapCompiler := map[string]string{}
	makeFile, err := os.Open(makeFilePath)
	if err != nil {
		return "", err
	}
	defer makeFile.Close()

	scanner := bufio.NewScanner(makeFile)
	for scanner.Scan() {
		text := scanner.Text()
		parts := rxMakefile.FindStringSubmatch(text)
		if len(parts) != 3 {
			continue
		}

		mapCompiler[parts[1]] = parts[2]
	}

	if err := scanner.Err(); err != nil {
		return "", err
	}

	// Convert variable in compiler flags
	for flagKey, flagValue := range mapCompiler {
		variables := rxCompilerVar.FindAllString(flagValue, -1)
		for _, variable := range variables {
			variableKey := rxCompilerVar.ReplaceAllString(variable, "$1")
			variableValue := mapCompiler[variableKey]
			flagValue = strings.Replace(flagValue, variable, variableValue, -1)
		}

		mapCompiler[flagKey] = strings.TrimSpace(flagValue)
	}

	// Fetch the needed flags for cgo
	cgoFlags := fmt.Sprintf("#cgo CFLAGS: %s\n", mapCompiler["CFLAGS"])
	cgoFlags += fmt.Sprintf("#cgo CXXFLAGS: %s\n", mapCompiler["CXXFLAGS"])
	cgoFlags += fmt.Sprintf("#cgo CXXFLAGS: %s\n", mapCompiler["INCPATH"])
	cgoFlags += fmt.Sprintf("#cgo LDFLAGS: %s\n", mapCompiler["LFLAGS"])
	cgoFlags += fmt.Sprintf("#cgo LDFLAGS: %s\n", mapCompiler["LIBS"])
	cgoFlags += fmt.Sprintln("#cgo CFLAGS: -Wno-unused-parameter -Wno-unused-variable -Wno-return-type")
	cgoFlags += fmt.Sprint("#cgo CXXFLAGS: -Wno-unused-parameter -Wno-unused-variable -Wno-return-type")

	return cgoFlags, nil
}

// CreateCgoFile creates cgo file in specified package,
// using cgo flags that generated by CreateCgoFlags().
func CreateCgoFile(dstDir string, cgoFlags string, pkgName string) error {
	// Make sure target directory is exists
	err := os.MkdirAll(dstDir, os.ModePerm)
	if err != nil {
		return err
	}

	// Get the package name
	if pkgName == "" {
		pkgName, err = getPackageNameFromDir(dstDir)
		if err != nil {
			return err
		}
	}

	// Create destination file
	fileName := fp.Join(dstDir, "qamel-cgo-"+pkgName+".go")
	dstFile, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	fileContent := fmt.Sprintln("package " + pkgName)
	fileContent += fmt.Sprintln()
	fileContent += fmt.Sprintln("/*")
	fileContent += fmt.Sprintln(cgoFlags)
	fileContent += fmt.Sprintln("*/")
	fileContent += fmt.Sprintln(`import "C"`)

	_, err = dstFile.WriteString(fileContent)
	if err != nil {
		return err
	}

	return dstFile.Sync()
}
